:scrollbar:
:data-uri:
:toc2:
:imagesdir: images

= RHEL 8 New Container tools

== Description
This Show&Tell is aimed to share some of the most important concepts and features of the new technology adopted by RHEL 8 to manage and implement containers, using podman, buildah and skopeo.

Duration: 4h with 2 breaks

Audience: IT Managers, Architects and technical staff who operates Linux

:numbered:

== New Container Technology
In RHEL 8 the docker package is replaced by the Container Tools module, which consists of Podman, Buildah, Skopeo and several other tidbits. These tools are compatible with the OCI specifications which means they can find, run, build and share containers with other tools that target the OCI standards including Docker CE, Docker EE, Kata Containers, CRI-O, and other container engines, registries, and tools. You can build with Buildah, and run with CRI-O. You can copy images from an AWS container registry to a local Podman instance. The OCI standards offer greater flexibility and choice.

== Open Container Initiative
The Open Container Initiative (OCI) is a lightweight, open governance structure (project), formed under the auspices of the Linux Foundation, for the express purpose of creating open industry standards around container formats and runtime.

The OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec). The Runtime Specification outlines how to run a “filesystem bundle” that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.

== What is a Container
A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.

Container images become containers at runtime and in the case of Docker containers - images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. ^(1)^

^(1)^ source: https://www.docker.com/resources/what-container

== Some Terminology

=== Container Image
An image is a file that can be pulled down form a repository server, then used locally as a mount point for a starting container.

=== Container Image Format
Is the format every container technology provider has defined to the image file. Nevertheless nowadays is more common to see this format pledged to to the format defined by the Open Container Initiative (OCI). Basically this format define the layers and the metadata inside the container image.

This OCI image format propose a container image comprised of tar files for each layer and a manifest in json format.

=== The Container Engine
Users usually emits requests such as pulling images, running containers, etc. This requests are accepted by a software called the container engine. The container engine, in RHEL 8, run the container from an image using runc, which is a, OCI compliant runtime.

=== Image layer

An image is made of one or several layers. Layers are connected together in a parent-child relationship, so each layer states the change between itself and the parent layer.

=== Tag

When an image builder creates a new repository, they will label the best image layer to use, and this label is called a tag. These tags can refer to versions of software in a repository. One of these tags, which is a special one, is "latest" that point outs to the latest version in a repository.

=== Repository

Repositories are made of layers and metadata that defines an image. Usually we refer to a repository as a container image.

When we specify a repository on the command line, the Container Engine is doing a search on the registry servers that are configured in its configuration files.

=== Container runtime

A container runtime is a software which is in charge of several actions and responsibilities:

* User input management
* Input over an API typically used by others
* Handling the metadata which will be passed to the container Container Runtime
* Using user input for overriding defaults
* Using defaults specified by the container image
* Getting the Container Images from the Registry Server
* Managing the container image for decompressing and expanding it on disk
* Preparing a mount point for the container
* Calling the Container Runtime

runc is the OCI compliant runtime most used by users and developers nowadays.

=== Namespace

Namespaces separate groups of repositories. The namespace is typically the username of the person sharing the image, but can also be a group name, or a logical name. For example, Red Hat uses the namespace to separate groups of repositories based on products listed on the Red Hat Federated Registry server.

=== Kernel Namespace

A kernel namespace is different from a namespace in which the former enables each container to have it’s own mount points, network interfaces, user identifiers, process identifiers, etc.

Typically, a regular Linux process is created using a version of exec() system call. When a container is created, the container engine makes the request to the kernel with a special system call called clone(), which in consequence creates the process ith its own virtual mount points, process ids, user ids, network interfaces, hostname, etc, benefiting the process isolation from the regular processes.

=== Container

A container is an instance of a container image comprised of standard Linux processes which are ussually created using clone() system call.

Red Hat Enterprise Linux implements Linux Containers using core technologies such as Control Groups (Cgroups) for Resource Management, Namespaces for Process Isolation, SELinux for Security, enabling secure multi-tenancy and reducing the potential for security exploits. All this is meant to provide you with an environment to producing and running enterprise-quality containers.

=== Container Host

A container host is an Operating System Instance in charge of running the processes that compose a container. This host could be a physical, an on premise virtual machine or a cloud virtual instance.

=== Registry Server

It is a server which stores repositories. Usually when the repository is not locally cached, it can be pulled from different registries. For example Red Hat Enterprise Linux is configured to pull repositories from registry.access.redhat.com first, then it will try docker.io (Docker Hub) and quay.io.

=== Orchestration

The orchestration comes into the scene when scalability and control is necessary in a consistent way. What a container orchestration does is:

* Schedules container workloads into a cluster dynamically.
* Defines standard file formats for maintaining all metadata.

The capabilities that are obtained by an orchestration system could be the following.

* Consistency
* Automation
* Assistance on flowcharts otherwise manual

Red Hat Openshift is a good example of a container orchestration.

== New Tools for this era

=== What is Podman?

Podman is an open-source project that is available on most Linux platforms and resides on GitHub. It is a daemonless container engine for developing, managing, and running Open Container Initiative (OCI) containers and container images on your Linux System. Podman provides a Docker-compatible command line front end that can simply alias the Docker cli, `alias docker=podman`.

In Red Hat Enterprise Linux exists a way to mimic the docker cli installing podman-docker package, which gives Docker's administrators the look and feel of Docker command line.

Containers under the control of Podman can either be run by root or by a non-privileged user. Podman manages the entire container ecosystem which includes pods, containers, container images, and container volumes using the libpod library. Podman specializes in all of the commands and functions that help you to maintain and modify OCI container images, such as pulling and tagging. It allows you to create, run, and maintain those containers created from those images in a production environment.

source: https://podman.io/whatis.html

=== What is Buildah?

Buildah is a command-line tool for building Open Container Initiative-compatible images quickly and easily. It can act as a drop-in replacement for the Docker daemon’s docker build command but is flexible enough to allow you to build images with whatever tools you prefer to use. Buildah is easy to incorporate into scripts and build pipelines, and best of all, it doesn’t require a running container daemon to build its image.

Podman can be used to build containers, so what is the difference wirth Buildah?.

Podman uses Buildah’s build functionality under the covers to create a container image, but the two projects have differences. The most important difference between Podman and Buildah is their concept of a container. Podman allows users to create traditional containers and the intent of these containers is to be controlled through the entirety of a container life cycle. Buildah containers, on the other hand, are really created to allow content to be added to the container image. Each project has a separate internal representation of a container that is not shared. Because of this you cannot see Podman containers from within Buildah or vice versa. However the internal representation of a container image is the same between Buildah and Podman. In consequence, any container image that has been created, pulled or modified by one can be seen and used by the other.

source: https://opensource.com/article/18/6/getting-started-buildah

=== What is Skopeo?

Skopeo is a command line utility that performs various operations on container images and image repositories. it Can work with OCI images as well as the original Docker v2 images.

Skopeo works with API V2 registries such as Docker registries, the Atomic registry, private registries, local directories and local OCI-layout directories. Skopeo does not require a daemon to be running to perform these operations which consist of:

* Copying an image from and to various storage mechanisms. For example you can copy images from one registry to another, without requiring privilege.

* Inspecting a remote image showing its properties including its layers, without requiring you to pull the image to the host.

* Deleting an image from an image repository.

* When required by the repository, skopeo can pass the appropriate credentials and certificates for authentication.

source: https://github.com/containers/skopeo

== Let's get hands dirty

In this session we are going to do several activities related to the following workflow:

=== Going with the basics

* Understand how Podman works in general

* Install RHEL 8 container tools module

[source,bash]
-----------------
# yum module install container-tools -y
-----------------

* Playing around with containers

- Play with Podman command

- Configure Registries
- Install podman-docker package
- Search for registries
- Pull an image with an application installed ready to be used
- Inspect images installed on the host
- Run a container from that image
- Access the service the running container is exposing

=== Container building

* Create a Dockerfile file
- Choose the base
- Update and install packages and libraries need by the service is going to be installed in the image
- Copy the source code to the image
- Define the start command to run the service once the container is started

=== Running and testing the container

* List the local images
* Run the container from the local image
* Test the service
* Backup the image

=== WebConsole to manage containers with Podman

* Installing the cockpit-podman plugin
* Managing a container lifecycle inside webconsole

== Resources and beyond

Sources

*
*
*
*
*
*
*
*
