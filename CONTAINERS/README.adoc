:scrollbar:
:data-uri:
:toc2:
:imagesdir: images

== Description
This Show&Tell is aimed to share some of the most important concepts and features of the new technology adopted by RHEL 8 to manage and implement containers, using podman, buildah and skopeo. 

Duration: 4h with 2 breaks

Audience: IT Managers, Architects and technical staff who operates Linux

:numbered:

== New Container Technology
In RHEL 8 the docker package is replaced by the Container Tools module, which consists of Podman, Buildah, Skopeo and several other tidbits. These tools are compatible with the OCI specifications which means they can find, run, build and share containers with other tools that target the OCI standards including Docker CE, Docker EE, Kata Containers, CRI-O, and other container engines, registries, and tools. You can build with Buildah, and run with CRI-O. You can copy images from an AWS container registry to a local Podman instance. The OCI standards offer greater flexibility and choice.

== Open Container Initiative
The Open Container Initiative (OCI) is a lightweight, open governance structure (project), formed under the auspices of the Linux Foundation, for the express purpose of creating open industry standards around container formats and runtime. 

The OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec). The Runtime Specification outlines how to run a “filesystem bundle” that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.

== What is a Container
A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.

Container images become containers at runtime and in the case of Docker containers - images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. ^(1)^

^(1)^ source: https://www.docker.com/resources/what-container

== Some Terminology

=== Container Image
An image is a file that can be pulled down form a repository server, then used locally as a mount point for a starting container.

=== Container Image Format
Is the format every container technology provider has defined to the image file. Nevertheless nowadays is more common to see this format pledged to to the format defined by the Open Container Innitiative (OCI). Basically this format define the layers and the metadata inside the container image.

This OCI image format propose a container image comprised of tar files for each layer and a manifest in json format.

=== The Container Engine
Users ussually emits requests such as pulling images, running containers, etc. This requests are accepted by a software called the container engine. The container engine, in RHEL 8, run the container from an image using runc, which is a, OCI compliant runtime. 

=== Image layer

An image is made of one or several layers. Layers are connected together in a parent-child relationship, so each layer states the change between itself and the parent layer.

=== Tag

When an image builder creates a new repository, they will label the best image layer to use, and this label is called a tag. These tags can refer to versions of software in a repository. One of these tags, which is a special one, is "latest" that point outs to the latest version in a repository.

=== Repository

Repositories are made of layers and metadata that defines an image. Ussually we refer to a repository as a container image.

When we specify a repository on the command line, the Container Engine is doing a serach on the refistry servers that are configured in its configuration files.

=== Container runtime

A container runtime is a softeare which is in charge of several actions and responsabilities:

* User input management
* Input over an API tipically used by others
* Handeling the metadata which will be passed to the container Container Runtime 
* Using user input for overriding defaults
* Using defaults specified by the container image
* Getting the Container Images from the Registry Server
* Managing the container image for decompressing and expanding it on disk
* Preparing a mount point for the container
* Calling the Container Runtime

runc is the OCI compliant runtime most used by users and developers nowadays.

=== Namespace

Namespaces separate groups of repositories. The namespace is typically the username of the person sharing the image, but can also be a group name, or a logical name. For example, Red Hat uses the namespace to separate groups of repositories based on products listed on the Red Hat Federated Registry server. 

=== Kernel Namespace

A kernel namespace is different from a namespace in which the former enables each container to have it’s own mount points, network interfaces, user identifiers, process identifiers, etc.

Tipically, a regular Linux process is created using a version of exec() system call. When a container is created, the container engine makes the request to the kernel with a special system call called clone(), which in consequence creates the process ith its own virtual mount points, process ids, user ids, network interfaces, hostname, etc, benefiting the process isolation from the regular processes.

=== Container

A container is an instance of a container image comprised of standard Linux processes which are ussually created using clone() system call.

Red Hat Enterprise Linux implements Linux Containers using core technologies such as Control Groups (Cgroups) for Resource Management, Namespaces for Process Isolation, SELinux for Security, enabling secure multi-tenancy and reducing the potential for security exploits. All this is meant to provide you with an environment to producing and running enterprise-quality containers.

=== Container Host

A container host is an Operating System Instance in charge of running the processes that compose a container. This host could be a physical, an on premise virtual machine or a cloud virtual instance.

=== Registry Server

It is a server which stores repositories. Ussually when the repository is not locally cached, it can be pulled from different registries. For exampl eRed Hat Enterprise Linux is configured to pull repositories from registry.access.redhat.com first, then it will try docker.io (Docker Hub) and quay.io.

=== Orchestration

The orchestration comes into the scene when scalability and control is necessary in a consistent way. What a contriner orchestrator does is:

* Schedules container workloads into a cluster dinamically.
* Defines standard file formats for maintaining all metadata.

The capabilities that are obtained by an orchestrator could be the following.

* Consistency
* Automation
* Assistance on flowcharts otherwise manual

Red Hat Openshift is a good example of a container orchestrator.




== Architecture
== New Tools for this era
=== What is podman?
==== Common Ground
==== Using podman on RHEL

= What is Buildah?
==== Common Ground
==== Using buildah on RHEL

== What is Skopeo
==== Common Ground
==== Using skopeo on RHEL

== WebConsole (cockpit) with containers
=== Installing the cockpit-podman plugin
=== Managing a container lifecycle inside webconsole

== Resources and beyond
